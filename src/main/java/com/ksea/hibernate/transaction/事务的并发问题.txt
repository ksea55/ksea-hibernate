事务的并发问题主要分为两类：读并发，写并发

读并发有分为三类:
1)脏读
     A事务读取了B事务未提交的数据.
     说明对于事务隔离级别设置较低的数据库，其是允许将未提交的数据写入到数据库中的
     但是，即使写入到数据库，若事务回滚，也是可以再将数据恢复为原数据的
     所以可能发生脏读的现象，A事务修改了某数据，但还未提交，此时B事务读取了该数据，
     但此时A事务又发生了回滚，那么B事务读取到的就是一个"不存在"的脏数据

2）不可重复读
     读取了已提交的事务。A事务先读取了一个数据，而后B事务修改(update或者delete)
     了该数据并提交。此时A事务再次读取该数据时，该数据已经呗修改或不存在，即无法在读
     到原来相同的数据


3）幻读
      也叫虚读 读取了已提交的事务，与不可重复读不同的是，发生了插入(insert)操作
      A事务先进行了某一条的检索操作，而后B事务插入了若干数据并提交，这些数据存在符合
      A事务检索条件的数据，此时A事务在做相同检索，其检索结果就会与第一次的不同
      在第二次读取除了"幻影"




解决这种问题 事务的隔离级别：
      为了防止读并发问题的发生，标准SQL定义了四个隔离级别，，级别由低到高
      分别为：读取未提交，读取已提交，可重复读，串行化。随着隔离级别的提高
      其防止并发的效果也是逐步提高，但其系统开销也是逐步提高的，代码的执行效率
      也是逐步降低的
      A:读取未提交->不防止任何并发问题
      B:读取已提交->防止脏读，可能出现不可重复读与幻读
      C:可重复读->防止脏读与不可重复读，可能出现幻读
      D:串行化->不存在并发问题

Mysql默认的事务隔离级别为：C可重复读，即防止了脏读与不可重复读，但可能会出现幻读
通过select @@global.tx_isolation 可以查询Mysql默认的事务隔离级别





-----------------------------------------------------------------------------------------------
写并发问题
 1)第一类丢失更新
       也称为回滚丢失更新，A,B事务同时读取某数据，并均做修改，A事务先进行了提交，
       而B事务有做回滚，此时A事务提交的更新数据丢失


 2)第二类丢失更新
       也称为提交丢失更新，A,B事务同时读取某数据，并均做修改，A事务先做了提交，
       然后B事务也做了提交，此时A事务提交的更新会被B事务的提交给覆盖


加锁机制
    通过加锁可以解决【写并发】问题，锁可以分为两类：

    乐观锁(Optimistic lock):
       每次访问数据时，都会乐观的认为其它事务此时肯定不会同时修改数据，但在真正修改时，
       会在代码中先判断数据是否已经被其它事务修改过，所以锁是加在代码中的。


    乐观锁实现原理：
        乐观锁是加在代码中的锁机制，一般充当乐观锁的有两类数据：版本号与时间戳
        他们的工作原理是相同的
        A,B事务从DB中读取数据时同时会读出一个数据版本号，当A事务将修改过的数据写入
        到DB中时，会使版本号增加1。当B事务发生回滚或覆盖时，会首先对比自己数据的版本号
        与DB中数据的版本号，若它们相等，则说明DB中数据没有发生变化，B事务可以将数据回滚到
        原始状态，或将修改写入到DB中，若小于DB中的版本号，则说明其它事务已经修改过该数据，将抛出异常


    悲观锁(Pessimistic lock):
        每次访问数据时，都会悲观的认为其它事务一定会同时修改该数据，所以，其在访问数据时，
        在数据库中就会先给数据加锁，以防止其它事务同事修改数据，所以锁是加载数据库中的


    悲观锁是加在DB中的锁机制，它又分为两类：

     写锁：由称为排它锁，当A事务对某数据加上排它锁后，A事务将独占该数据，可对该数据进行
     读、写操作，但其他事务是不能再为该数据添加任何锁的，直到A事务将排它锁解锁，将数据释放

     在SQL语句中，若要为本次操作(事务)添加排它锁，则可在正常的SQL语句最后添加上 for update即可
       例如：select * from student where age<20 for update


      读锁：又称为共享锁。当A事务对某数据加上共享锁后，只能对数据进行读操作，但其他事务也同时
        可以为该数据添加共享锁，读取该数据，但不能添加写锁，直到所有事务将共享锁解锁，将数据释放。
        才可以再对数据添加排它锁。

        在SQL语句中 若要为本次操作(事务)添加共享锁，则可以在正常的SQL语句最后添加上lock in share mode即可
        例如:select * from student where age<20 lock in share mode
